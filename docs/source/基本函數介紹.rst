=============
基本函數介紹
=============

四則運算
=============

.. function :: + : lhs + rhs

將 lhs（左值）與 rhs（右值）相加，得到回傳值。型別轉換 table：


+--------+--------+----------------+
| lhs    | rhs    | return val     |
+========+========+================+
| p_int  | p_int  | p_int          |
+--------+--------+----------------+
| p_int  | n_int  | int            |
+--------+--------+----------------+
| p_int  | z_int  | p_int          |
+--------+--------+----------------+
| p_int  | int    | int            |
+--------+--------+----------------+
| n_int  | n_int  | n_int          |
+--------+--------+----------------+
| n_int  | p_int  | int            |
+--------+--------+----------------+
| n_int  | z_int  | n_int          |
+--------+--------+----------------+
| n_int  | int    | int            |
+--------+--------+----------------+
| z_int  | p_int  | p_int          |
+--------+--------+----------------+
| z_int  | n_int  | n_int          |
+--------+--------+----------------+
| z_int  | z_int  | z_int          |
+--------+--------+----------------+
| z_int  | int    | int            |
+--------+--------+----------------+
| int    | n_int  | int            |
+--------+--------+----------------+
| int    | p_int  | int            |
+--------+--------+----------------+
| int    | z_int  | int            |
+--------+--------+----------------+
| int    | int    | int            |
+--------+--------+----------------+
| dou    | dou    | dou            |
+--------+--------+----------------+

.. function :: - : lhs - rhs

將 lhs（左值）與 rhs（右值）相減，得到回傳值。型別轉換 table：


+--------+--------+----------------+
| lhs    | rhs    | return val     |
+========+========+================+
| p_int  | p_int  | int            |
+--------+--------+----------------+
| p_int  | n_int  | p_int          |
+--------+--------+----------------+
| p_int  | z_int  | p_int          |
+--------+--------+----------------+
| p_int  | int    | int            |
+--------+--------+----------------+
| n_int  | n_int  | int            |
+--------+--------+----------------+
| n_int  | p_int  | n_int          |
+--------+--------+----------------+
| n_int  | z_int  | n_int          |
+--------+--------+----------------+
| n_int  | int    | int            |
+--------+--------+----------------+
| z_int  | p_int  | n_int          |
+--------+--------+----------------+
| z_int  | n_int  | p_int          |
+--------+--------+----------------+
| z_int  | z_int  | z_int          |
+--------+--------+----------------+
| z_int  | int    | int            |
+--------+--------+----------------+
| int    | n_int  | int            |
+--------+--------+----------------+
| int    | p_int  | int            |
+--------+--------+----------------+
| int    | z_int  | int            |
+--------+--------+----------------+
| int    | int    | int            |
+--------+--------+----------------+
| dou    | dou    | dou            |
+--------+--------+----------------+


.. function :: - : lhs * rhs

將 lhs（左值）與 rhs（右值）相乘，得到回傳值。型別轉換 table：


+--------+--------+----------------+
| lhs    | rhs    | return val     |
+========+========+================+
| p_int  | p_int  | p_int          |
+--------+--------+----------------+
| p_int  | n_int  | n_int          |
+--------+--------+----------------+
| p_int  | z_int  | z_int          |
+--------+--------+----------------+
| p_int  | int    | int            |
+--------+--------+----------------+
| n_int  | n_int  | p_int          |
+--------+--------+----------------+
| n_int  | p_int  | n_int          |
+--------+--------+----------------+
| n_int  | z_int  | z_int          |
+--------+--------+----------------+
| n_int  | int    | int            |
+--------+--------+----------------+
| z_int  | p_int  | z_int          |
+--------+--------+----------------+
| z_int  | n_int  | z_int          |
+--------+--------+----------------+
| z_int  | z_int  | z_int          |
+--------+--------+----------------+
| z_int  | int    | z_int          |
+--------+--------+----------------+
| int    | n_int  | int            |
+--------+--------+----------------+
| int    | p_int  | int            |
+--------+--------+----------------+
| int    | z_int  | z_int          |
+--------+--------+----------------+
| int    | int    | int            |
+--------+--------+----------------+
| dou    | dou    | dou            |
+--------+--------+----------------+

.. function :: / : lhs * rhs

將 lhs（左值）與 rhs（右值）相乘，得到回傳值。型別轉換 table：

.. note :: rhs 只能為 p_int、n_int，或 dou，**不可為 z_int 或 int**。

+--------+--------+----------------+
| lhs    | rhs    | return val     |
+========+========+================+
| p_int  | p_int  | p_int          |
+--------+--------+----------------+
| p_int  | n_int  | n_int          |
+--------+--------+----------------+
| n_int  | n_int  | p_int          |
+--------+--------+----------------+
| n_int  | p_int  | n_int          |
+--------+--------+----------------+
| z_int  | p_int  | z_int          |
+--------+--------+----------------+
| z_int  | n_int  | z_int          |
+--------+--------+----------------+
| int    | n_int  | int            |
+--------+--------+----------------+
| int    | p_int  | int            |
+--------+--------+----------------+
| dou    | dou    | dou            |
+--------+--------+----------------+

定義變數 (=)
=============

非函數
---------


語法如下：

::

  Type var_name = value; #非函數

例如：

::

  p_int x = 9; # 定義正整數
  
  dou pi = 3.1416; # 定義浮點數值

  dou z = pi; # 設定值

  int x = lambda(int x){return x + 1;}(8); # 8 + 1 = 9 



  ..note :: 因為 tshunhue 裡面，所有變數都是不可變物件， ``=`` 不可以拿來重新設定值。定義閉包也一樣。


函數（閉包）
---------------

.. _defining-lambda:

閉包的定義比較複雜。但大致如下：

::

  type_of_function
  fn_var = lambda(x1 *[,...]*){*body*};

通常 `type_of_function`（函數型別）與 `fn_var`（函數名）要換行。不換行空白也行，如`(-> int int) id_int = lambda(x){return x;};`。

基本函數定義：

::

  '''單引數函數'''
  (-> int int)
  id_int = lambda(x){return x;};

  '''雙引數函數'''
  (-> (int int) int) # 兩個以上引數要加括號 ()
  custom_add = lambda(x, y){return x + y;};


多載函數如下定義：

::

   overload fn_var = [
    type_of_fn1 lambda(arg1, *...*){body1},
    type_of_fn2 lambda(arg2, *...*){body2}*, ...*];


::    

  '''type of the function:
  (caseof
      (-> int int)
      (-> dou dou)
  )
  '''
  overload custom_overload_id = [(-> int int)
                            lambda(x)
                            {return x;},
                            (-> dou dou)
                            lambda(x)
                            {return x;}];

參數化多型函數如下定義：
::

  (para_fun ((a [, ...]) in type) type_of_fun)

  fn = lambda(arg [,...]){body};

  # 或是

  (para_fun ((a [, ...]) in any) type_of_fun)

  fn = lambda(arg [,...]){body}; # any: 任意非閉包型別

例如

::

  (para_fun ((a) in any) (-> a a))
  para_poly_id = lambda(x){return x};

參數化多態不支援將閉包型別參數化。如果需要參數化，需要用 struct 包起來。

匿名函數
============


.. function ::  lambda(Type x1){ block }
               lambda(Type1 x1, Type2 x2, ...){ block }

匿名函數 lambda，輸入時需強制標示型別（除非用於定義非多載函數的時候）。輸出如 block。除非不返回回傳值，否則一律要加 return 標示回傳值。

有關於函數定義，請參考 :ref:`定義函數<defining-lambda>`

事例如下：
::

  block = expressions+; return expression;

例如：

::

  lambda(int x){
    return x + 4;
  };

  # 不傳回值
  lambda(int x){
    print(x);
  };

所有函數都是第一類物件與閉包，用 lexical scope 保存前文變數。


